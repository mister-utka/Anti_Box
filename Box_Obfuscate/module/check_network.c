#include <windows.h>#include <stdio.h>#include <iphlpapi.h>#include <netioapi.h>#include <Iphlpapi.h>#include <ws2tcpip.h>#include <string.h>#include "proxy_funck.c"/*#pragma comment(lib, "iphlpapi.lib")#pragma comment(lib, "ws2_32.lib")*/DWORD xcdblXgowhieysn(PIP_ADAPTER_INFO* ulfmeAwbxtxzxoe)       // Функция для получения информации об интерфейсах{DWORD hhxeoOlbvyjpmngz = 0;DWORD dwRetVal = 0;dwRetVal = uipstSpoudfhrrx(*ulfmeAwbxtxzxoe, &hhxeoOlbvyjpmngz);     // Вызываем функцию для получения размера буфераif (dwRetVal == ERROR_BUFFER_OVERFLOW) {*ulfmeAwbxtxzxoe = (PIP_ADAPTER_INFO) malloc(hhxeoOlbvyjpmngz);if (*ulfmeAwbxtxzxoe == NULL) {return -1;}}dwRetVal = uipstSpoudfhrrx(*ulfmeAwbxtxzxoe, &hhxeoOlbvyjpmngz);     // Получаем информацию об адаптерахreturn dwRetVal;}const char* ckpveKyvzvcnmef(BYTE* macAddress)                // Функция для проверки совпадения MAC-адреса с одним из префиксов{struct MacPrefix {                  // Массив невалидных префиксов MAC адресовBYTE prefix[3];                 // Первые три байта MAC адресаconst char* description;        // Описание};struct MacPrefix validPrefixes[] = {{{0x00, 0x50, 0x56}, "ivdqtPwuynvrdaehiy"},{{0x00, 0x0C, 0x29}, "ivdqtPwuynvrdaehiy"},{{0x00, 0x05, 0x69}, "ivdqtPwuynvrdaehiy"},{{0x00, 0x1c, 0x14}, "ivdqtPwuynvrdaehiy"},{{0x00, 0x03, 0xff}, "zzxtuNvxrqnhbmo"},{{0x00, 0x0d, 0x3a}, "zzxtuNvxrqnhbmo"},{{0x00, 0x50, 0xf2}, "zzxtuNvxrqnhbmo"},{{0x7c, 0x1e, 0x52}, "zzxtuNvxrqnhbmo"},{{0x00, 0x12, 0x5a}, "zzxtuNvxrqnhbmo"},{{0x00, 0x15, 0x5d}, "zzxtuNvxrqnhbmo"},{{0x00, 0x17, 0xfa}, "zzxtuNvxrqnhbmo"},{{0x28, 0x18, 0x78}, "zzxtuNvxrqnhbmo"},{{0x7c, 0xed, 0x8d}, "zzxtuNvxrqnhbmo"},{{0x00, 0x1d, 0xd8}, "zzxtuNvxrqnhbmo"},{{0x00, 0x22, 0x48}, "zzxtuNvxrqnhbmo"},{{0x00, 0x25, 0xae}, "zzxtuNvxrqnhbmo"},{{0x60, 0x45, 0xbd}, "zzxtuNvxrqnhbmo"},{{0xdc, 0xb4, 0xc4}, "zzxtuNvxrqnhbmo"},{{0x00, 0x1c, 0x42}, "odiexBiipptf"},{{0x00, 0x0f, 0x4b}, "uhnhpTtjtmn"},{{0x00, 0x16, 0x3e}, "uyuubEuaqzycpgsgo"},{{0x08, 0x00, 0x27}, "hiaeaIqbpo"},};for (int i=0; i < sizeof(validPrefixes)/sizeof(validPrefixes[0]); i++) {    // Проход по масиву префиксов и проверка MAC-адресаif (macAddress[0] == validPrefixes[i].prefix[0] &&macAddress[1] == validPrefixes[i].prefix[1] &&macAddress[2] == validPrefixes[i].prefix[2]) {return validPrefixes[i].description;}}return NULL;}int nvcgwMfokbhmzypks(){PIP_ADAPTER_INFO ulfmeAwbxtxzxoe = NULL;                   // Указатель на структуру, в которой будет хранится инфа о сетевых интерфейсахDWORD dwRetVal = xcdblXgowhieysn(&ulfmeAwbxtxzxoe);   // Получение информации об интерфейсахif (dwRetVal == ERROR_SUCCESS) {PIP_ADAPTER_INFO pAdapter = ulfmeAwbxtxzxoe;           // Указатель на текущий адптер (инициализируется перез записью)while (pAdapter) {                                  // Перебираем все адаптеры в спискеPIP_ADDR_STRING pIpAddr = &pAdapter->IpAddressList;/*while (pIpAddr) {                                           // Печать всех IP-адресов, связынных с адаптеромprintf("IP Address %s\n", pIpAddr->IpAddress.String);   // Выводим IP адрес текцщего узлаpIpAddr = pIpAddr->Next;                                // Переходим к следующему IP адресу если он есть}*/for(int i = 0; i < pAdapter->AddressLength; i++) {  // Проходим по всем байтам MAC адреса и выводим в HEX форматеif(i != pAdapter->AddressLength - 1) {}}const char* description = ckpveKyvzvcnmef(pAdapter->Address);    // Проверка на совпадение MAC адреса с одним из известных префиксовif (description) {                                              // Если совпадение найденоreturn 4;} else {}pAdapter = pAdapter->Next;}}return 0;}