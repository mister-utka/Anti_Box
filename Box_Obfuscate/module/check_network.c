#include <windows.h>#include <stdio.h>#include <iphlpapi.h>#include <netioapi.h>#include <Iphlpapi.h>#include <ws2tcpip.h>#include <string.h>#include "proxy_funck.c"/*// Необходимо для использования функции GetAdaptersInfo#pragma comment(lib, "iphlpapi.lib")#pragma comment(lib, "ws2_32.lib")*/DWORD svmiuOihfkz(PIP_ADAPTER_INFO* rwmlyZzxxbnicnivti)       // Функция для получения информации об интерфейсах{    DWORD inpolBzgkekcndo = 0;    DWORD dwRetVal = 0;    dwRetVal = tupzkMhpodlnxdjd(*rwmlyZzxxbnicnivti, &inpolBzgkekcndo);     // Вызываем функцию для получения размера буфера    if (dwRetVal == ERROR_BUFFER_OVERFLOW) {        *rwmlyZzxxbnicnivti = (PIP_ADAPTER_INFO) malloc(inpolBzgkekcndo);        if (*rwmlyZzxxbnicnivti == NULL) {            // printf("Memory allocation error");            return -1;        }    }    dwRetVal = tupzkMhpodlnxdjd(*rwmlyZzxxbnicnivti, &inpolBzgkekcndo);     // Получаем информацию об адаптерах    return dwRetVal;}const char* qohugUakdy(BYTE* macAddress)                // Функция для проверки совпадения MAC-адреса с одним из префиксов{    struct MacPrefix {                  // Массив невалидных префиксов MAC адресов        BYTE prefix[3];                 // Первые три байта MAC адреса        const char* description;        // Описание    };    struct MacPrefix validPrefixes[] = {        {{0x00, 0x50, 0x56}, "lvctlYokspxnxhffmf"},        {{0x00, 0x0C, 0x29}, "lvctlYokspxnxhffmf"},        {{0x00, 0x05, 0x69}, "lvctlYokspxnxhffmf"},        {{0x00, 0x1c, 0x14}, "lvctlYokspxnxhffmf"},        {{0x00, 0x03, 0xff}, "jjdqfMwrkmefugs"},        {{0x00, 0x0d, 0x3a}, "jjdqfMwrkmefugs"},        {{0x00, 0x50, 0xf2}, "jjdqfMwrkmefugs"},        {{0x7c, 0x1e, 0x52}, "jjdqfMwrkmefugs"},        {{0x00, 0x12, 0x5a}, "jjdqfMwrkmefugs"},        {{0x00, 0x15, 0x5d}, "jjdqfMwrkmefugs"},        {{0x00, 0x17, 0xfa}, "jjdqfMwrkmefugs"},        {{0x28, 0x18, 0x78}, "jjdqfMwrkmefugs"},        {{0x7c, 0xed, 0x8d}, "jjdqfMwrkmefugs"},        {{0x00, 0x1d, 0xd8}, "jjdqfMwrkmefugs"},        {{0x00, 0x22, 0x48}, "jjdqfMwrkmefugs"},        {{0x00, 0x25, 0xae}, "jjdqfMwrkmefugs"},        {{0x60, 0x45, 0xbd}, "jjdqfMwrkmefugs"},        {{0xdc, 0xb4, 0xc4}, "jjdqfMwrkmefugs"},        {{0x00, 0x1c, 0x42}, "tpuntPswaotzr"},        {{0x00, 0x0f, 0x4b}, "tifxbYlumaizkeahpoh"},        {{0x00, 0x16, 0x3e}, "izoyeKgvlnwjarwpp"},        {{0x08, 0x00, 0x27}, "odctkOskdmteedvepwoo"},    };    for (int i=0; i < sizeof(validPrefixes)/sizeof(validPrefixes[0]); i++) {    // Проход по масиву префиксов и проверка MAC-адреса        if (macAddress[0] == validPrefixes[i].prefix[0] &&            macAddress[1] == validPrefixes[i].prefix[1] &&            macAddress[2] == validPrefixes[i].prefix[2]) {            return validPrefixes[i].description;        }    }    return NULL;}int kyhcvEastmgtvymzrkmx(){    PIP_ADAPTER_INFO rwmlyZzxxbnicnivti = NULL;                   // Указатель на структуру, в которой будет хранится инфа о сетевых интерфейсах    DWORD dwRetVal = svmiuOihfkz(&rwmlyZzxxbnicnivti);   // Получение информации об интерфейсах    if (dwRetVal == ERROR_SUCCESS) {        PIP_ADAPTER_INFO pAdapter = rwmlyZzxxbnicnivti;           // Указатель на текущий адптер (инициализируется перез записью)        while (pAdapter) {                                  // Перебираем все адаптеры в списке            // printf("Adapter Name: %s\n", pAdapter->AdapterName);            // printf("Description: %s\n", pAdapter->Description);            PIP_ADDR_STRING pIpAddr = &pAdapter->IpAddressList;            /*            while (pIpAddr) {                                           // Печать всех IP-адресов, связынных с адаптером                printf("IP Address %s\n", pIpAddr->IpAddress.String);   // Выводим IP адрес текцщего узла                pIpAddr = pIpAddr->Next;                                // Переходим к следующему IP адресу если он есть            }            */            // printf("MAC address: ");            for(int i = 0; i < pAdapter->AddressLength; i++) {  // Проходим по всем байтам MAC адреса и выводим в HEX формате                // printf("%02X", pAdapter->Address[i]);                if(i != pAdapter->AddressLength - 1) {                    // printf(":");                }            }            // printf("\n");            const char* description = qohugUakdy(pAdapter->Address);    // Проверка на совпадение MAC адреса с одним из известных префиксов            if (description) {                                              // Если совпадение найдено                // printf("This MAC address matches a known prefix: %s\n", description);                return 4;            } else {                // printf("No known prefix match found for this MAC address.\n");            }            // printf("\n");            pAdapter = pAdapter->Next;        }    }    return 0;}