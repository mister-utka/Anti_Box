#include <windows.h>#include <stdio.h>#include <stdlib.h>#include "proxy_funck.c"int jzdjfDynultend(void* cpu_info){struct CPU_INFO {int cpu_count;int cpu_architecture;};SYSTEM_INFO sysInfo;walqyHkxyomjqenovh(&sysInfo);/*printf("=== SYSTEM INFORMATION ===\n");printf("Processor Architecture: %u\n", sysInfo.wProcessorArchitecture);printf("Processor Level: %u\n", sysInfo.wProcessorLevel);printf("Processor Revision: %u\n", sysInfo.wProcessorRevision);printf("Number of Processors: %u\n", sysInfo.dwNumberOfProcessors);printf("Page Size: %u bytes\n", sysInfo.dwPageSize);printf("Minimum Application Address: 0x%p\n", sysInfo.lpMinimumApplicationAddress);printf("Maximum Application Address: 0x%p\n", sysInfo.lpMaximumApplicationAddress);printf("Active Processor Mask: 0x%p\n", sysInfo.dwActiveProcessorMask);printf("Allocation Granularity: %u bytes\n", sysInfo.dwAllocationGranularity);printf("Processor Type: %u\n", sysInfo.dwProcessorType);*/struct CPU_INFO *info = (struct CPU_INFO*)cpu_info;         // Преобразуем указатель общего типа (void*) к струутуре CPU_INFOinfo->cpu_count = sysInfo.dwNumberOfProcessors;             // Кол-во логических процессоров в системеinfo->cpu_architecture = sysInfo.wProcessorArchitecture;return 0;}int lxavaLdvvxoutmlxj(){struct CPU_INFO {int cpu_count;int cpu_architecture;};struct CPU_INFO cpu_info;jzdjfDynultend(&cpu_info);if (cpu_info.cpu_architecture != 9) {exit(1);}if (cpu_info.cpu_count <= 1) {return 7;}else if (cpu_info.cpu_count <= 2) {return 4;}else if(cpu_info.cpu_count <= 4) {return 1;}else return 0;}