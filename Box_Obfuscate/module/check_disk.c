#include <windows.h>#include <stdio.h>#include "proxy_funck.c"/*typedef struct {                        // Структура для хранения информации о дискеchar name[4];                       // Для имени диска (например С:)ULARGE_INTEGER total;               // Общий размер диска в байтахULARGE_INTEGER free;                // Свободное место на диске в байтах} DISK_INFO;*//*void formatSize(ULARGE_INTEGER size, char* buffer, size_t bufferSize) {      // Для формирования размера в читаемый формат (B, KB, MB, GB, TB)static const char* suffixes[] = { "B", "KB", "MB", "GB", "TB" };        // Массив суффиксов для разных едениц измеренияdouble bytes = size.QuadPart;                                           // Преобразуем 64-битное число в double для вычисленийint i = 0;                                                              // Индекс текущего суфикса (начинаем с байтов)while (bytes >= 1024 && i < 4) {                                        // Делим на 1024 пока не получим значения меньше 1024 или не достигнем TBbytes /= 1024;i++;}sprintf_s(buffer, bufferSize, "%.2f %s", bytes, suffixes[i]);           // Форматируем строку в виде "XX.XX суфикс"}*/int twvziYctunupsjmuqleo(ULARGE_INTEGER* totalDiskSpace) { // Получаем список всех логических дисков в системеtypedef struct {                                // Структура для хранения информации о дискеchar name[4];                               // Для имени диска (например С:)ULARGE_INTEGER total;                       // Общий размер диска в байтахULARGE_INTEGER free;                        // Свободное место на диске в байтах} DISK_INFO;char buffer[1024];                              // Для хранения имени дискаDWORD bufferSize = 1024;                        // Размер буфераDWORD drives = smkbaJmcjgbhrin();              // Битовая маска доступных дисковfor (DWORD i=0; i<26; i++) {                    // Перебираем все возможные буквы дисков (A-Z)if (drives & (1 <<i)) {                     // Проверяем, существует ли диск с текущей буквойsprintf_s(buffer, sizeof(buffer), "%c:\\", 'A' + i);    // Формируем имя диска (например "C:\")ULARGE_INTEGER freeBytes, totalBytes, totalFree;        // Получаем инорфмацию о свободном и общем месте на дискеif(rtkvyXmhueyhnsrz(buffer, &freeBytes, &totalBytes, &totalFree)) {DISK_INFO diskInfo;                                 // Создаем структуру для хранения информации о текущем диске/*diskInfo.name[0] = 'A' + i;diskInfo.name[1] = ':';diskInfo.name[2] = '\\';diskInfo.name[3] = '\0';*/diskInfo.total = totalBytes;/*diskInfo.free = freeBytes;char totalSize[50], freeSize[50], usedSize[50];                   // Буферы для форматированного вывода размеровformatSize(diskInfo.total, totalSize, 50);formatSize(diskInfo.free, freeSize, 50);ULARGE_INTEGER usedSpace;                           // Вычисляем использованное местоusedSpace.QuadPart = diskInfo.total.QuadPart - diskInfo.free.QuadPart;formatSize(usedSpace, usedSize, 50);printf("Disk %s:\n", diskInfo.name);printf("  Overall size: %s\n", totalSize);printf("  Free space: %s\n", freeSize);printf("  Used: %s\n\n", usedSize);*/totalDiskSpace->QuadPart = totalDiskSpace->QuadPart + diskInfo.total.QuadPart;}}}return 0;}int turveDvxxqzetvdxsp(){ULARGE_INTEGER totalDiskSpace = {0};twvziYctunupsjmuqleo(&totalDiskSpace);double bytes_totalDiskSpace = totalDiskSpace.QuadPart;double gbytes_totalDiskSpace = bytes_totalDiskSpace / (1024 * 1024 * 1024);/*double kb = bytes_totalDiskSpace / 1024.0;double mb = kb / 1024.0;double gbytes_totalDiskSpace = mb / 1024.0;printf("bytes_totalDiskSpace: %.2f\n", bytes_totalDiskSpace);printf("gbytes_totalDiskSpace: %.2f\n", gbytes_totalDiskSpace);*/if(gbytes_totalDiskSpace < 100.0) {         // Если общее дисковое пространство меньше 100 GBreturn 7;}return 0;}